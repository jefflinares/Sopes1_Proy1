<!DOCTYPE html>
<meta charset="utf-8">
<style type="text/css">
table {
  font-family: "Helvetica", "Lucida Sans", "Lucida Sans Unicode", "Luxi Sans", Tahoma, sans-serif;
  box-shadow: 1px 1px 10px rgba(0,0,0,0.5);
  border-collapse: collapse;
  border-spacing: 0;
}
table {
  margin: auto;
}
table, td, th {
  padding: 7px;
  text-align: center;
  border: 1px solid rgb(8,48,107);
}
th {
  background-color: rgb(8,81,156);
  color: white;
}
</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
<script src="https://d3js.org/d3.v3.js"></script>​
<script>
    /*
jdata = [
    {
        "name":"bob",
        "salary":13000,
        "friends":[
            {
                "name": "sarah",
                "salary":10000
            },
            {
                "name": "bill",
                "salary":5000
            }
        ]
    },
    {
        "name":"marge",
        "salary":10000,
        "friends":[
            {
                "name": "rhonda",
                "salary":10000
            },
            {
                "name": "mike",
                "salary":5000,
                "hobbies":[
                    {
                        "name":"surfing",
                        "frequency":10
                    },
                    {
                        "name":"surfing",
                        "frequency":15
                    }
                ]
            }
        ]
    },
    {
        "name":"joe",
        "salary":10000,
        "friends":[
            {
                "name": "harry",
                "salary":10000
            },
            {
                "name": "sally",
                "salary":5000
            }
        ]
    }
];
*/

const socket = io();

jdata = [ getData() ];



d3.select("body").selectAll("table")
    .data([JSON.parse(j)])
.enter().append("table")
    .call(recurse);




function recurse(sel) {
  // sel is a d3.selection of one or more empty tables
  sel.each(function(d) {
    // d is an array of objects
    var colnames,
        tds,
        table = d3.select(this);

    // obtain column names by gathering unique key names in all 1st level objects
    // following method emulates a set by using the keys of a d3.map()
    colnames = d                                                          // array of objects
        .reduce(function(p,c) { return p.concat(d3.keys(c)); }, [])       // array with all keynames
        .reduce(function(p,c) { return (p.set(c,0), p); }, d3.map())      // map with unique keynames as keys
        .keys();                                                          // array with unique keynames (arb. order)

    // colnames array is in arbitrary order
    // sort colnames here if required

    // create header row using standard 1D data join and enter()
    table.append("thead").append("tr").selectAll("th")
        .data(colnames)
      .enter().append("th")
        .text(function(d) { return d; });

    // create the table cells by using nested 2D data join and enter()
    // see also http://bost.ocks.org/mike/nest/
    tds = table.append("tbody").selectAll("tr")
        .data(d)                            // each row gets one object
      .enter().append("tr").selectAll("td")
        .data(function(d) {                 // each cell gets one value
          return colnames.map(function(k) { // for each colname (i.e. key) find the corresponding value
            return d[k] || "";              // use empty string if key doesn't exist for that object
          });
        })
      .enter().append("td");

    // cell contents depends on the data bound to the cell
    // fill with text if data is not an Array
    tds.filter(function(d) { return !(d instanceof Array); })
        .text(function(d) { return d; });
    // fill with a new table if data is an Array
    tds.filter(function(d) { return (d instanceof Array); })
        .append("table")
        .call(recurse);
  });
}



function getData(){
    socket.emit("proc");

        socket.on("proc", (procInfo) => {
        
        try {
            
            //console.log(procInfo);
            var j = "{\n";
            j += '"Processes":[\n';
            var i = 0;
            //CREAR TABLA Y AÑADIR INFO DE LOS PROCESOS
            //var div = document.getElementById("tablaProcesos");
            //div.innerHTML = "";
            //var table_body = createTable(div) ;
            
            for(let i = 0; i < procInfo.Processes.length; i ++)
            {
            if(i > 0){
                j+=",\n";
            }  
            
            j += getJson(procInfo.Processes[i], "\t");
            

            // addProcInfo(procInfo.Processes[i], 0, table_body);


            }

            j += "\t]\n}";


            return JSON.parse(j);
            //console.log(j);
            //console.log("{"+JSON.stringify(procInfo.Processes)+"}");
            
            //jTable(j);
        }catch (exception) {
            console.log(exception);
        }

        });

        function getJson(proc, tab ) 
        {
        
            tab = tab + "\t";
            let j = tab+"{\n";
            j += tab+'"Pid":"'+proc.Pid+'",\n';
            j += tab+'"Name":"'+proc.Name+'",\n';
            j += tab+'"User":"'+proc.User+'",\n';
            j += tab+'"Status":"'+proc.Status+'",\n';
            j += tab+'"Memory":"'+proc.Memory+'",\n';
            j += tab+'"PPid":"'+proc.PPid+'"';
            
            if(proc.Hijos !== undefined && proc.Hijos.length>0)
            {
                j += ',\n'+tab+'"Hijos":[\n';

                for(let i = 0; i<proc.Hijos.length; i++){
                if(i > 0)
                {
                    j += tab+ ",\n";
                }
                j += getJson(proc.Hijos[i], tab);
                }
                j += tab+"]\n";
            }
            return j + "}\n";
        }

}









</script>